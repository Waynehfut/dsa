# :blue_book: 第三章 栈(Stack)

当你在计算机中启动计算器程序，并按下计算的公式时，你是否想过，`1+2=3`是如何计算的？

![计算器](https://raw.githubusercontent.com/Waynehfut/img/img/img/202309010943297.png)

当我们在浏览网页时，浏览器是怎么记得我们上一步浏览了那个页面呢？

![浏览器历史记录](https://raw.githubusercontent.com/Waynehfut/img/img/img/202309010941772.png)

这一切都需要用到我们本章的内容，为了实现上述需求，有关算法专家设计了称之为 **栈(Stack)** 的数据结构。栈是一类特殊的表，它是限定了仅在表尾进行插入或删除的表。其中加入数据称之为入栈(Push)，出栈称之为(Pop)，它的头尾也有了特殊的别称，执行增删操作的称之为栈顶(Top)，最底层的数据称之为栈底(Bottom)，如果没有数据存储，那这个栈称之为空栈。需要注意的是，栈只有栈顶事可以访存的，那也就意味着先进入到栈中的数据是被“压”在最低端，是一个 **后进先出(Last In First Out, LIFO)** 的结构。
![栈的基本形态](https://raw.githubusercontent.com/Waynehfut/img/img/img/202309011001052.png)

:::info 拓展阅读
栈是较早出现在计算机中的数据结构之一，在计算机内存管理中，栈是实现进程局部优先级控制最有效的办法，例如局部变量的新建和释放、局部函数的参数值传递等等，有兴趣可进一步阅读。[Java Heap Space vs Stack - Memory Allocation in Java | DigitalOcean](https://www.digitalocean.com/community/tutorials/java-heap-space-vs-stack-memory)
:::

## 栈 ADT

在讨论了上述内容后，我们来看下栈的基本操作：

| 操作方法  | 功能描述        |
| --------- | --------------- |
| push(x)   | 将对象 x 压入栈 |
| pop()     | 将栈顶元素移除  |
| getSize() | 获取栈大小      |
| isEmpty() | 是否为空        |
| top()     | 取栈顶          |

上述操作是 Java 接口中对栈的相关方法定义，在使用过程中则会有以下的效果

| 操作方法  | 操作           | 栈(右侧为栈顶) | 输出  |
| --------- | -------------- | -------------- | ----- |
| push(5)   | 将 5 压入栈    | (5)            |       |
| push(3)   | 将 3 压入栈    | (5,3)          |       |
| getSize() | 获取当前栈大小 | (5,3)          | 2     |
| pop()     | 移除栈顶       | (5)            |       |
| isEmpty() | 是否为空       | (5)            | false |
| top()     | 取栈顶         | (5)            | 5     |

## 栈的应用

那有了栈以后，我们就可以利用它完成前述的工作了，比如完成一个计算器的核心计算逻辑。
比如说，我们计算：
$$2*5+6-5*(8-3)=-9$$
在计算器里，我们输入的顺序应当是：
![计算器计算](https://raw.githubusercontent.com/Waynehfut/img/img/img/202309011706838.png)
但是我们按照计算优先级规则，实际上是先计算`2*5=10`后,计算`10+6=16`后，再计算`8-3=5`，接着计算`5*5=25`,最后`16-25=-9`的，如果我们将这样的顺序排列出来的话，实际上是`2,5,*,6,+,5,8,3,-,*,-`，这种记数方法称之为后缀记法，对应的表达式称之为后缀表达式。

## 栈的实现

由于栈是一个表，实际上它也和表有类似的实现方式，例如使用`ArrayList`和`LinkedList`分别实现的栈，称之为顺序栈和链栈。

### 顺序栈

### 链栈
